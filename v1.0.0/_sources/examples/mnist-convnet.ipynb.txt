{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# MNIST convolutional network\n",
    "\n",
    "In this example we will show how to build and train\n",
    "a convolutional network in NengoDL,\n",
    "and then deploy that network on Loihi.\n",
    "\n",
    "We'll use the basic MNIST dataset to demonstrate the steps.\n",
    "The input data are images of handwritten digits,\n",
    "and the goal is for the network to classify each image as 0-9.\n",
    "\n",
    "We will assume here that the reader is somewhat familiar with NengoDL,\n",
    "and focus on the issue of how to use NengoDL to train a network for Loihi.\n",
    "For a more basic introduction to NengoDL, check out\n",
    "[the documentation](https://www.nengo.ai/nengo-dl)\n",
    "and [examples](https://www.nengo.ai/nengo-dl/examples)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "\n",
    "import os\n",
    "\n",
    "import nengo\n",
    "import nengo_dl\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import tensorflow as tf\n",
    "\n",
    "try:\n",
    "    import requests\n",
    "\n",
    "    has_requests = True\n",
    "except ImportError:\n",
    "    has_requests = False\n",
    "\n",
    "import nengo_loihi"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# helper function for later\n",
    "def download(fname, drive_id):\n",
    "    \"\"\"Download a file from Google Drive.\n",
    "\n",
    "    Adapted from https://stackoverflow.com/a/39225039/1306923\n",
    "    \"\"\"\n",
    "\n",
    "    def get_confirm_token(response):\n",
    "        for key, value in response.cookies.items():\n",
    "            if key.startswith(\"download_warning\"):\n",
    "                return value\n",
    "        return None\n",
    "\n",
    "    def save_response_content(response, destination):\n",
    "        CHUNK_SIZE = 32768\n",
    "\n",
    "        with open(destination, \"wb\") as f:\n",
    "            for chunk in response.iter_content(CHUNK_SIZE):\n",
    "                if chunk:  # filter out keep-alive new chunks\n",
    "                    f.write(chunk)\n",
    "\n",
    "    if os.path.exists(fname):\n",
    "        return\n",
    "    if not has_requests:\n",
    "        link = \"https://drive.google.com/open?id=%s\" % drive_id\n",
    "        raise RuntimeError(\n",
    "            \"Cannot find '%s'. Download the file from\\n  %s\\n\"\n",
    "            \"and place it in %s.\" % (fname, link, os.getcwd())\n",
    "        )\n",
    "\n",
    "    url = \"https://docs.google.com/uc?export=download\"\n",
    "    session = requests.Session()\n",
    "    response = session.get(url, params={\"id\": drive_id}, stream=True)\n",
    "    token = get_confirm_token(response)\n",
    "    if token is not None:\n",
    "        params = {\"id\": drive_id, \"confirm\": token}\n",
    "        response = session.get(url, params=params, stream=True)\n",
    "    save_response_content(response, fname)\n",
    "\n",
    "\n",
    "# load mnist dataset\n",
    "(train_images, train_labels), (\n",
    "    test_images,\n",
    "    test_labels,\n",
    ") = tf.keras.datasets.mnist.load_data()\n",
    "\n",
    "# flatten images\n",
    "train_images = train_images.reshape((train_images.shape[0], -1))\n",
    "test_images = test_images.reshape((test_images.shape[0], -1))\n",
    "\n",
    "# plot some examples\n",
    "for i in range(3):\n",
    "    plt.figure()\n",
    "    plt.imshow(np.reshape(train_images[i], (28, 28)))\n",
    "    plt.axis(\"off\")\n",
    "    plt.title(str(train_labels[i]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We'll begin by defining a simple function to build a \"convolutional layer\".\n",
    "This is just a `nengo.Connection` and `nengo.Ensemble` put together,\n",
    "but we'll be doing this a lot so we'll use this function\n",
    "to put them together in an easy-to-use bundle."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def conv_layer(x, *args, activation=True, **kwargs):\n",
    "    # create a Conv2D transform with the given arguments\n",
    "    conv = nengo.Convolution(*args, channels_last=False, **kwargs)\n",
    "\n",
    "    if activation:\n",
    "        # add an ensemble to implement the activation function\n",
    "        layer = nengo.Ensemble(conv.output_shape.size, 1).neurons\n",
    "    else:\n",
    "        # no nonlinearity, so we just use a node\n",
    "        layer = nengo.Node(size_in=conv.output_shape.size)\n",
    "\n",
    "    # connect up the input object to the new layer\n",
    "    nengo.Connection(x, layer, transform=conv)\n",
    "\n",
    "    # print out the shape information for our new layer\n",
    "    print(\"LAYER\")\n",
    "    print(conv.input_shape.shape, \"->\", conv.output_shape.shape)\n",
    "\n",
    "    return layer, conv"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next we define the structure of our network.\n",
    "Because we need to keep the number of neurons and axons per core\n",
    "below the Loihi hardware limits,\n",
    "we adopt a somewhat unusual network architecture.\n",
    "We'll have a relatively small core network,\n",
    "so that each layer fits on one Loihi core,\n",
    "and then repeat that network several times in parallel, summing their output.\n",
    "We can think of this as a variation on [ensemble learning\n",
    "](https://en.wikipedia.org/wiki/Ensemble_averaging_(machine_learning)).\n",
    "See the [CIFAR-10\n",
    "example](https://www.nengo.ai/nengo-loihi/examples/cifar10-convnet.html)\n",
    "for a different approach that uses NengoLoihi's BlockShape functionality\n",
    "to automatically split larger layers across cores."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dt = 0.001  # simulation timestep\n",
    "presentation_time = 0.1  # input presentation time\n",
    "max_rate = 100  # neuron firing rates\n",
    "# neuron spike amplitude (scaled so that the overall output is ~1)\n",
    "amp = 1 / max_rate\n",
    "# input image shape\n",
    "input_shape = (1, 28, 28)\n",
    "n_parallel = 2  # number of parallel network repetitions\n",
    "\n",
    "with nengo.Network(seed=0) as net:\n",
    "    # set up the default parameters for ensembles/connections\n",
    "    nengo_loihi.add_params(net)\n",
    "    net.config[nengo.Ensemble].neuron_type = nengo.SpikingRectifiedLinear(amplitude=amp)\n",
    "    net.config[nengo.Ensemble].max_rates = nengo.dists.Choice([max_rate])\n",
    "    net.config[nengo.Ensemble].intercepts = nengo.dists.Choice([0])\n",
    "    net.config[nengo.Connection].synapse = None\n",
    "\n",
    "    # the input node that will be used to feed in input images\n",
    "    inp = nengo.Node(\n",
    "        nengo.processes.PresentInput(test_images, presentation_time), size_out=28 * 28\n",
    "    )\n",
    "\n",
    "    # the output node provides the 10-dimensional classification\n",
    "    out = nengo.Node(size_in=10)\n",
    "\n",
    "    # build parallel copies of the network\n",
    "    for _ in range(n_parallel):\n",
    "        layer, conv = conv_layer(\n",
    "            inp, 1, input_shape, kernel_size=(1, 1), init=np.ones((1, 1, 1, 1))\n",
    "        )\n",
    "        # first layer is off-chip to translate the images into spikes\n",
    "        net.config[layer.ensemble].on_chip = False\n",
    "        layer, conv = conv_layer(layer, 6, conv.output_shape, strides=(2, 2))\n",
    "        layer, conv = conv_layer(layer, 24, conv.output_shape, strides=(2, 2))\n",
    "        nengo.Connection(layer, out, transform=nengo_dl.dists.Glorot())\n",
    "\n",
    "    out_p = nengo.Probe(out, label=\"out_p\")\n",
    "    out_p_filt = nengo.Probe(out, synapse=nengo.Alpha(0.01), label=\"out_p_filt\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The next step is to optimize the parameters of the network using NengoDL.\n",
    "\n",
    "First we set up the input/target data for the training and test datasets."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# set up training data, adding the time dimension (with size 1)\n",
    "minibatch_size = 200\n",
    "train_images = train_images[:, None, :]\n",
    "train_labels = train_labels[:, None, None]\n",
    "\n",
    "# for the test data evaluation we'll be running the network over time\n",
    "# using spiking neurons, so we need to repeat the input/target data\n",
    "# for a number of timesteps (based on the presentation_time)\n",
    "n_steps = int(presentation_time / dt)\n",
    "test_images = np.tile(test_images[: minibatch_size * 2, None, :], (1, n_steps, 1))\n",
    "test_labels = np.tile(test_labels[: minibatch_size * 2, None, None], (1, n_steps, 1))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next we need to define our error functions.\n",
    "\n",
    "For training we will use the standard categorical cross-entropy loss function.\n",
    "\n",
    "For evaluation we will use\n",
    "classification accuracy (the % of images classified correctly)\n",
    "as an intuitive measure of how well the network is doing.\n",
    "Since we will be running the network over time during evaluation,\n",
    "we modify the loss function slightly so that it only assesses the\n",
    "accuracy on the last timestep."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def classification_accuracy(y_true, y_pred):\n",
    "    return 100 * tf.metrics.sparse_categorical_accuracy(y_true[:, -1], y_pred[:, -1])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we create the NengoDL simulator\n",
    "and run the training using the `sim.fit` function.\n",
    "\n",
    "More details on how to use NengoDL to optimize a model\n",
    "can be found here: https://www.nengo.ai/nengo-dl/user-guide.html.\n",
    "\n",
    "To speed up this example we can set `do_training=False`\n",
    "to load some pre-trained parameters.\n",
    "If you have the `requests` package installed,\n",
    "we will download these automatically.\n",
    "If not, download the following file\n",
    "to the directory containing this notebook.\n",
    "\n",
    "- [mnist_params.npz](\n",
    "https://drive.google.com/open?id=1geZoS-Nz-u_XeeDv3cdZgNjUxDOpgXe5)\n",
    "\n",
    "Note that in order to run `do_training=True`,\n",
    "you will need to have TensorFlow installed with GPU support."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "do_training = False\n",
    "\n",
    "with nengo_dl.Simulator(net, minibatch_size=minibatch_size, seed=0) as sim:\n",
    "    if do_training:\n",
    "        sim.compile(loss={out_p_filt: classification_accuracy})\n",
    "        print(\n",
    "            \"accuracy before training: %.2f%%\"\n",
    "            % sim.evaluate(test_images, {out_p_filt: test_labels}, verbose=0)[\"loss\"]\n",
    "        )\n",
    "\n",
    "        # run training\n",
    "        sim.compile(\n",
    "            optimizer=tf.optimizers.RMSprop(0.001),\n",
    "            loss={out_p: tf.losses.SparseCategoricalCrossentropy(from_logits=True)},\n",
    "        )\n",
    "        sim.fit(train_images, train_labels, epochs=5)\n",
    "\n",
    "        sim.compile(loss={out_p_filt: classification_accuracy})\n",
    "        print(\n",
    "            \"accuracy after training: %.2f%%\"\n",
    "            % sim.evaluate(test_images, {out_p_filt: test_labels}, verbose=0)[\"loss\"]\n",
    "        )\n",
    "\n",
    "        sim.save_params(\"./mnist_params\")\n",
    "    else:\n",
    "        download(\"mnist_params.npz\", \"1geZoS-Nz-u_XeeDv3cdZgNjUxDOpgXe5\")\n",
    "        sim.load_params(\"./mnist_params\")\n",
    "\n",
    "    # store trained parameters back into the network\n",
    "    sim.freeze_params(net)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we built it, the network has\n",
    "no synaptic filters on the neural connections.\n",
    "This works well during training,\n",
    "but we can see that the error is still somewhat high\n",
    "when we evaluate it using spiking neurons.\n",
    "We can improve performance\n",
    "by adding synaptic filters to our trained network."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for conn in net.all_connections:\n",
    "    conn.synapse = 0.005\n",
    "\n",
    "if do_training:\n",
    "    with nengo_dl.Simulator(net, minibatch_size=minibatch_size) as sim:\n",
    "        sim.compile(loss={out_p_filt: classification_accuracy})\n",
    "        print(\n",
    "            \"accuracy w/ synapse: %.2f%%\"\n",
    "            % sim.evaluate(test_images, {out_p_filt: test_labels}, verbose=0)[\"loss\"]\n",
    "        )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we can load our trained network, with synaptic filters, onto Loihi.\n",
    "This is as easy as passing the network to `nengo_loihi.Simulator`\n",
    "and running it, there is no extra work required.\n",
    "We will give the network 50 test images,\n",
    "and use that to evaluate the classification error."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "n_presentations = 50\n",
    "\n",
    "# if running on Loihi, increase the max input spikes per step\n",
    "hw_opts = dict(snip_max_spikes_per_step=120)\n",
    "with nengo_loihi.Simulator(\n",
    "    net,\n",
    "    dt=dt,\n",
    "    precompute=False,\n",
    "    hardware_options=hw_opts,\n",
    ") as sim:\n",
    "    # run the simulation on Loihi\n",
    "    sim.run(n_presentations * presentation_time)\n",
    "\n",
    "    # check classification accuracy\n",
    "    step = int(presentation_time / dt)\n",
    "    output = sim.data[out_p_filt][step - 1 :: step]\n",
    "\n",
    "    correct = 100 * np.mean(\n",
    "        np.argmax(output, axis=-1) == test_labels[:n_presentations, -1, 0]\n",
    "    )\n",
    "    print(\"loihi accuracy: %.2f%%\" % correct)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can also plot the output activity from the Loihi network\n",
    "as we show it different test images,\n",
    "to see what this performance looks like in practice."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "n_plots = 10\n",
    "plt.figure()\n",
    "\n",
    "plt.subplot(2, 1, 1)\n",
    "images = test_images.reshape(-1, 28, 28, 1)[::step]\n",
    "ni, nj, nc = images[0].shape\n",
    "allimage = np.zeros((ni, nj * n_plots, nc), dtype=images.dtype)\n",
    "for i, image in enumerate(images[:n_plots]):\n",
    "    allimage[:, i * nj : (i + 1) * nj] = image\n",
    "if allimage.shape[-1] == 1:\n",
    "    allimage = allimage[:, :, 0]\n",
    "plt.imshow(allimage, aspect=\"auto\", interpolation=\"none\", cmap=\"gray\")\n",
    "\n",
    "plt.subplot(2, 1, 2)\n",
    "plt.plot(sim.trange()[: n_plots * step], sim.data[out_p_filt][: n_plots * step])\n",
    "plt.legend([\"%d\" % i for i in range(10)], loc=\"best\")"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python",
   "pygments_lexer": "ipython3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 3
}
